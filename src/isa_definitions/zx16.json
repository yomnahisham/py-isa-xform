{
    "name": "ZX16",
    "version": "1.0",
    "description": "ZX16 16-bit RISC-V inspired ISA",
    "instruction_size": 16,
    "word_size": 16,
    "endianness": "little",
    "address_space": {
      "size": 65536,
      "default_code_start": 32
    },
    "registers": {
      "general_purpose": [
        {"name": "x0", "size": 16, "alias": ["t0"], "description": "Temporary (caller-saved)"},
        {"name": "x1", "size": 16, "alias": ["ra"], "description": "Return address"},
        {"name": "x2", "size": 16, "alias": ["sp"], "description": "Stack pointer"},
        {"name": "x3", "size": 16, "alias": ["s0"], "description": "Saved/Frame pointer"},
        {"name": "x4", "size": 16, "alias": ["s1"], "description": "Saved"},
        {"name": "x5", "size": 16, "alias": ["t1"], "description": "Temporary (caller-saved)"},
        {"name": "x6", "size": 16, "alias": ["a0"], "description": "Argument 0/Return value"},
        {"name": "x7", "size": 16, "alias": ["a1"], "description": "Argument 1"}
      ]
    },
    "instructions": [
      {
        "mnemonic": "ADD",
        "format": "R-type",
        "description": "Add registers (two-operand)",
        "syntax": "ADD rd, rs2",
        "semantics": "rd = (rd + rs2) & 0xFFFF",
        "implementation": "# Add instruction implementation\nrd_val = read_register(operands['rd'])\nrs2_val = read_register(operands['rs2'])\nresult = (rd_val + rs2_val) & 0xFFFF\nwrite_register(operands['rd'], result)\n# Set flags\nset_flag('Z', result == 0)\nset_flag('N', (result & 0x8000) != 0)\nset_flag('C', (rd_val + rs2_val) > 0xFFFF)\nset_flag('V', ((rd_val & 0x8000) == (rs2_val & 0x8000)) and ((result & 0x8000) != (rd_val & 0x8000)))",
        "encoding": {
          "fields": [
            {"name": "funct4", "bits": "15:12", "value": "0000"},
            {"name": "rs2", "bits": "11:9", "type": "register"},
            {"name": "rd", "bits": "8:6", "type": "register"},
            {"name": "func3", "bits": "5:3", "value": "000"},
            {"name": "opcode", "bits": "2:0", "value": "000"}
          ]
        }
      },
      {
        "mnemonic": "SUB",
        "format": "R-type",
        "description": "Subtract registers (two-operand)",
        "syntax": "SUB rd, rs2",
        "semantics": "rd = (rd - rs2) & 0xFFFF",
        "implementation": "# Subtract instruction implementation\nrd_val = read_register(operands['rd'])\nrs2_val = read_register(operands['rs2'])\nresult = (rd_val - rs2_val) & 0xFFFF\nwrite_register(operands['rd'], result)\n# Set flags\nset_flag('Z', result == 0)\nset_flag('N', (result & 0x8000) != 0)\nset_flag('C', rd_val >= rs2_val)\nset_flag('V', ((rd_val & 0x8000) != (rs2_val & 0x8000)) and ((result & 0x8000) == (rs2_val & 0x8000)))",
        "encoding": {
          "fields": [
            {"name": "funct4", "bits": "15:12", "value": "0001"},
            {"name": "rs2", "bits": "11:9", "type": "register"},
            {"name": "rd", "bits": "8:6", "type": "register"},
            {"name": "func3", "bits": "5:3", "value": "000"},
            {"name": "opcode", "bits": "2:0", "value": "000"}
          ]
        }
      },
      {
        "mnemonic": "SLT",
        "format": "R-type",
        "description": "Set if less than (signed)",
        "syntax": "SLT rd, rs2",
        "semantics": "rd = (rd < rs2)",
        "implementation": "# Set if less than (signed) implementation\nrd_val = read_register(operands['rd'])\nrs2_val = read_register(operands['rs2'])\n# Sign extend to 32 bits for comparison\nrd_signed = rd_val if (rd_val & 0x8000) == 0 else rd_val - 0x10000\nrs2_signed = rs2_val if (rs2_val & 0x8000) == 0 else rs2_val - 0x10000\nresult = 1 if rd_signed < rs2_signed else 0\nwrite_register(operands['rd'], result)",
        "encoding": {
          "fields": [
            {"name": "funct4", "bits": "15:12", "value": "0010"},
            {"name": "rs2", "bits": "11:9", "type": "register"},
            {"name": "rd", "bits": "8:6", "type": "register"},
            {"name": "func3", "bits": "5:3", "value": "001"},
            {"name": "opcode", "bits": "2:0", "value": "000"}
          ]
        }
      },
      {
        "mnemonic": "SLTU",
        "format": "R-type",
        "description": "Set if less than (unsigned)",
        "syntax": "SLTU rd, rs2",
        "semantics": "rd = (unsigned(rd) < unsigned(rs2))",
        "implementation": "# Set if less than (unsigned) implementation\nrd_val = read_register(operands['rd'])\nrs2_val = read_register(operands['rs2'])\nresult = 1 if rd_val < rs2_val else 0\nwrite_register(operands['rd'], result)",
        "encoding": {
          "fields": [
            {"name": "funct4", "bits": "15:12", "value": "0011"},
            {"name": "rs2", "bits": "11:9", "type": "register"},
            {"name": "rd", "bits": "8:6", "type": "register"},
            {"name": "func3", "bits": "5:3", "value": "010"},
            {"name": "opcode", "bits": "2:0", "value": "000"}
          ]
        }
      },
      {
        "mnemonic": "SLL",
        "format": "R-type",
        "description": "Shift left logical",
        "syntax": "SLL rd, rs2",
        "semantics": "rd = (rd << (rs2 & 0x7)) & 0xFFFF",
        "implementation": "# Shift left logical implementation\nrd_val = read_register(operands['rd'])\nrs2_val = read_register(operands['rs2'])\nshift_amount = rs2_val & 0xF\nresult = (rd_val << shift_amount) & 0xFFFF\nwrite_register(operands['rd'], result)\n# Set flags\nset_flag('Z', result == 0)\nset_flag('N', (result & 0x8000) != 0)",
        "encoding": {
          "fields": [
            {"name": "funct4", "bits": "15:12", "value": "0100"},
            {"name": "rs2", "bits": "11:9", "type": "register"},
            {"name": "rd", "bits": "8:6", "type": "register"},
            {"name": "func3", "bits": "5:3", "value": "011"},
            {"name": "opcode", "bits": "2:0", "value": "000"}
          ]
        }
      },
      {
        "mnemonic": "SRL",
        "format": "R-type",
        "description": "Shift right logical",
        "syntax": "SRL rd, rs2",
        "semantics": "rd = (rd >> (rs2 & 0x7)) & 0xFFFF",
        "implementation": "# Shift right logical implementation\nrd_val = read_register(operands['rd'])\nrs2_val = read_register(operands['rs2'])\nshift_amount = rs2_val & 0xF\nresult = (rd_val >> shift_amount) & 0xFFFF\nwrite_register(operands['rd'], result)\n# Set flags\nset_flag('Z', result == 0)\nset_flag('N', (result & 0x8000) != 0)",
        "encoding": {
          "fields": [
            {"name": "funct4", "bits": "15:12", "value": "0101"},
            {"name": "rs2", "bits": "11:9", "type": "register"},
            {"name": "rd", "bits": "8:6", "type": "register"},
            {"name": "func3", "bits": "5:3", "value": "011"},
            {"name": "opcode", "bits": "2:0", "value": "000"}
          ]
        }
      },
      {
        "mnemonic": "SRA",
        "format": "R-type",
        "description": "Shift right arithmetic",
        "syntax": "SRA rd, rs2",
        "semantics": "rd = (rd >> (rs2 & 0xF) & 0xFFFF)",
        "implementation": "# Shift right arithmetic implementation\nrd_val = read_register(operands['rd'])\nrs2_val = read_register(operands['rs2'])\nshift_amount = rs2_val & 0xF\n# Sign extend for arithmetic shift\nrd_signed = rd_val if (rd_val & 0x8000) == 0 else rd_val - 0x10000\nresult = (rd_signed >> shift_amount) & 0xFFFF\nwrite_register(operands['rd'], result)\n# Set flags\nset_flag('Z', result == 0)\nset_flag('N', (result & 0x8000) != 0)",
        "encoding": {
          "fields": [
            {"name": "funct4", "bits": "15:12", "value": "0110"},
            {"name": "rs2", "bits": "11:9", "type": "register"},
            {"name": "rd", "bits": "8:6", "type": "register"},
            {"name": "func3", "bits": "5:3", "value": "011"},
            {"name": "opcode", "bits": "2:0", "value": "000"}
          ]
        }
      },
      {
        "mnemonic": "OR",
        "format": "R-type",
        "description": "Bitwise OR",
        "syntax": "OR rd, rs2",
        "semantics": "rd = (rd | rs2) & 0xFFFF",
        "implementation": "# Bitwise OR implementation\nrd_val = read_register(operands['rd'])\nrs2_val = read_register(operands['rs2'])\nresult = (rd_val | rs2_val) & 0xFFFF\nwrite_register(operands['rd'], result)\n# Set flags\nset_flag('Z', result == 0)\nset_flag('N', (result & 0x8000) != 0)",
        "encoding": {
          "fields": [
            {"name": "funct4", "bits": "15:12", "value": "0111"},
            {"name": "rs2", "bits": "11:9", "type": "register"},
            {"name": "rd", "bits": "8:6", "type": "register"},
            {"name": "func3", "bits": "5:3", "value": "100"},
            {"name": "opcode", "bits": "2:0", "value": "000"}
          ]
        }
      },
      {
        "mnemonic": "AND",
        "format": "R-type",
        "description": "Bitwise AND",
        "syntax": "AND rd, rs2",
        "semantics": "rd = (rd & rs2) & 0xFFFF",
        "implementation": "# Bitwise AND implementation\nrd_val = read_register(operands['rd'])\nrs2_val = read_register(operands['rs2'])\nresult = (rd_val & rs2_val) & 0xFFFF\nwrite_register(operands['rd'], result)\n# Set flags\nset_flag('Z', result == 0)\nset_flag('N', (result & 0x8000) != 0)",
        "encoding": {
          "fields": [
            {"name": "funct4", "bits": "15:12", "value": "1000"},
            {"name": "rs2", "bits": "11:9", "type": "register"},
            {"name": "rd", "bits": "8:6", "type": "register"},
            {"name": "func3", "bits": "5:3", "value": "101"},
            {"name": "opcode", "bits": "2:0", "value": "000"}
          ]
        }
      },
      {
        "mnemonic": "XOR",
        "format": "R-type",
        "description": "Bitwise XOR",
        "syntax": "XOR rd, rs2",
        "semantics": "rd = (rd ^ rs2) & 0xFFFF",
        "implementation": "# Bitwise XOR implementation\nrd_val = read_register(operands['rd'])\nrs2_val = read_register(operands['rs2'])\nresult = (rd_val ^ rs2_val) & 0xFFFF\nwrite_register(operands['rd'], result)\n# Set flags\nset_flag('Z', result == 0)\nset_flag('N', (result & 0x8000) != 0)",
        "encoding": {
          "fields": [
            {"name": "funct4", "bits": "15:12", "value": "1001"},
            {"name": "rs2", "bits": "11:9", "type": "register"},
            {"name": "rd", "bits": "8:6", "type": "register"},
            {"name": "func3", "bits": "5:3", "value": "110"},
            {"name": "opcode", "bits": "2:0", "value": "000"}
          ]
        }
      },
      {
        "mnemonic": "MV",
        "format": "R-type",
        "description": "Move register",
        "syntax": "MV rd, rs2",
        "semantics": "rd = rs2 & 0xFFFF",
        "implementation": "# Move register implementation\nrs2_val = read_register(operands['rs2'])\nwrite_register(operands['rd'], rs2_val)",
        "encoding": {
          "fields": [
            {"name": "funct4", "bits": "15:12", "value": "1010"},
            {"name": "rs2", "bits": "11:9", "type": "register"},
            {"name": "rd", "bits": "8:6", "type": "register"},
            {"name": "func3", "bits": "5:3", "value": "111"},
            {"name": "opcode", "bits": "2:0", "value": "000"}
          ]
        }
      },
      {
        "mnemonic": "JR",
        "format": "R-type",
        "description": "Jump register",
        "syntax": "JR rd",
        "semantics": "PC = rd & 0xFFFF",
        "implementation": "# Jump register implementation\nrd_val = read_register(operands['rd'])\n# Set PC to register value\ncontext.pc = rd_val & 0xFFFF",
        "encoding": {
          "fields": [
            {"name": "funct4", "bits": "15:12", "value": "1011"},
            {"name": "rs2", "bits": "11:9", "value": "000"},
            {"name": "rd", "bits": "8:6", "type": "register"},
            {"name": "func3", "bits": "5:3", "value": "000"},
            {"name": "opcode", "bits": "2:0", "value": "000"}
          ]
        }
      },
      {
        "mnemonic": "JALR",
        "format": "R-type",
        "description": "Jump and link register",
        "syntax": "JALR rd, rs2",
        "semantics": "rd = (PC + 2) & 0xFFFF; PC = rs2 & 0xFFFF",
        "implementation": "# Jump and link register implementation\nrs2_val = read_register(operands['rs2'])\n# Save return address\nreturn_addr = context.pc + 2\nwrite_register(operands['rd'], return_addr)\n# Set PC to register value\ncontext.pc = rs2_val & 0xFFFF",
        "encoding": {
          "fields": [
            {"name": "funct4", "bits": "15:12", "value": "1100"},
            {"name": "rs2", "bits": "11:9", "type": "register"},
            {"name": "rd", "bits": "8:6", "type": "register"},
            {"name": "func3", "bits": "5:3", "value": "000"},
            {"name": "opcode", "bits": "2:0", "value": "000"}
          ]
        }
      },
      {
        "mnemonic": "ADDI",
        "format": "I-type",
        "description": "Add immediate",
        "syntax": "ADDI rd, imm",
        "semantics": "rd = (rd + sign_extend(imm, 7)) & 0xFFFF",
        "implementation": "# Add immediate implementation\nrd_val = read_register(operands['rd'])\nimm_val = operands['imm']\n# Sign extend 7-bit immediate\nif imm_val & 0x40:\n    imm_val = imm_val | 0xFF80\nresult = (rd_val + imm_val) & 0xFFFF\nwrite_register(operands['rd'], result)\n# Set flags\nset_flag('Z', result == 0)\nset_flag('N', (result & 0x8000) != 0)",
        "encoding": {
          "fields": [
            {"name": "imm", "bits": "15:9", "type": "immediate", "signed": true},
            {"name": "rd", "bits": "8:6", "type": "register"},
            {"name": "func3", "bits": "5:3", "value": "000"},
            {"name": "opcode", "bits": "2:0", "value": "001"}
          ]
        }
      },
      {
        "mnemonic": "SLTI",
        "format": "I-type",
        "description": "Set if less than immediate (signed)",
        "syntax": "SLTI rd, imm",
        "semantics": "rd = (rd < sign_extend(imm, 7)) ? 1 : 0",
        "implementation": "# Set if less than immediate (signed) implementation\nrd_val = read_register(operands['rd'])\nimm_val = operands['imm']\n# Sign extend 7-bit immediate\nif imm_val & 0x40:\n    imm_val = imm_val | 0xFF80\n# Sign extend to 32 bits for comparison\nrd_signed = rd_val if (rd_val & 0x8000) == 0 else rd_val - 0x10000\nimm_signed = imm_val if (imm_val & 0x8000) == 0 else imm_val - 0x10000\nresult = 1 if rd_signed < imm_signed else 0\nwrite_register(operands['rd'], result)",
        "encoding": {
          "fields": [
            {"name": "imm", "bits": "15:9", "type": "immediate", "signed": true},
            {"name": "rd", "bits": "8:6", "type": "register"},
            {"name": "func3", "bits": "5:3", "value": "001"},
            {"name": "opcode", "bits": "2:0", "value": "001"}
          ]
        }
      },
      {
        "mnemonic": "SLTUI",
        "format": "I-type",
        "description": "Set if less than immediate (unsigned)",
        "syntax": "SLTUI rd, imm",
        "semantics": "rd = (unsigned(rd) < unsigned(sign_extend(imm, 7))) ? 1 : 0",
        "implementation": "# Set if less than immediate (unsigned) implementation\nrd_val = read_register(operands['rd'])\nimm_val = operands['imm']\n# Sign extend 7-bit immediate\nif imm_val & 0x40:\n    imm_val = imm_val | 0xFF80\n# Treat as unsigned comparison\nresult = 1 if rd_val < (imm_val & 0xFFFF) else 0\nwrite_register(operands['rd'], result)",
        "encoding": {
          "fields": [
            {"name": "imm", "bits": "15:9", "type": "immediate", "signed": true},
            {"name": "rd", "bits": "8:6", "type": "register"},
            {"name": "func3", "bits": "5:3", "value": "010"},
            {"name": "opcode", "bits": "2:0", "value": "001"}
          ]
        }
      },
      {
        "mnemonic": "SLLI",
        "format": "I-type",
        "description": "Shift left logical immediate",
        "syntax": "SLLI rd, imm",
        "semantics": "rd = (rd << (imm & 0x7F)) & 0xFFFF",
        "implementation": "# Shift left logical immediate implementation\nrd_val = read_register(operands['rd'])\nimm_val = operands['imm']\nshift_amount = imm_val & 0xF\nresult = (rd_val << shift_amount) & 0xFFFF\nwrite_register(operands['rd'], result)\n# Set flags\nset_flag('Z', result == 0)\nset_flag('N', (result & 0x8000) != 0)",
        "encoding": {
          "fields": [
            {"name": "imm", "bits": "15:9", "type": "immediate", "signed": false},
            {"name": "rd", "bits": "8:6", "type": "register"},
            {"name": "func3", "bits": "5:3", "value": "011"},
            {"name": "opcode", "bits": "2:0", "value": "001"}
          ]
        }
      },
      {
        "mnemonic": "SRLI",
        "format": "I-type",
        "description": "Shift right logical immediate",
        "syntax": "SRLI rd, imm",
        "semantics": "rd = (rd >> (imm & 0x7F)) & 0xFFFF",
        "implementation": "# Shift right logical immediate implementation\nrd_val = read_register(operands['rd'])\nimm_val = operands['imm']\nshift_amount = imm_val & 0xF\nresult = (rd_val >> shift_amount) & 0xFFFF\nwrite_register(operands['rd'], result)\n# Set flags\nset_flag('Z', result == 0)\nset_flag('N', (result & 0x8000) != 0)",
        "encoding": {
          "fields": [
            {"name": "imm", "bits": "15:9", "type": "immediate", "signed": false},
            {"name": "rd", "bits": "8:6", "type": "register"},
            {"name": "func3", "bits": "5:3", "value": "011"},
            {"name": "opcode", "bits": "2:0", "value": "001"}
          ]
        }
      },
      {
        "mnemonic": "SRAI",
        "format": "I-type",
        "description": "Shift right arithmetic immediate",
        "syntax": "SRAI rd, imm",
        "semantics": "rd = (rd >> (imm & 0x7F)) & 0xFFFF",
        "implementation": "# Shift right arithmetic immediate implementation\nrd_val = read_register(operands['rd'])\nimm_val = operands['imm']\nshift_amount = imm_val & 0xF\n# Sign extend for arithmetic shift\nrd_signed = rd_val if (rd_val & 0x8000) == 0 else rd_val - 0x10000\nresult = (rd_signed >> shift_amount) & 0xFFFF\nwrite_register(operands['rd'], result)\n# Set flags\nset_flag('Z', result == 0)\nset_flag('N', (result & 0x8000) != 0)",
        "encoding": {
          "fields": [
            {"name": "imm", "bits": "15:9", "type": "immediate", "signed": false},
            {"name": "rd", "bits": "8:6", "type": "register"},
            {"name": "func3", "bits": "5:3", "value": "011"},
            {"name": "opcode", "bits": "2:0", "value": "001"}
          ]
        }
      },
      {
        "mnemonic": "ORI",
        "format": "I-type",
        "description": "OR immediate",
        "syntax": "ORI rd, imm",
        "semantics": "rd = (rd | sign_extend(imm, 7)) & 0xFFFF",
        "implementation": "# OR immediate implementation\nrd_val = read_register(operands['rd'])\nimm_val = operands['imm']\n# Sign extend 7-bit immediate\nif imm_val & 0x40:\n    imm_val = imm_val | 0xFF80\nresult = (rd_val | (imm_val & 0xFFFF)) & 0xFFFF\nwrite_register(operands['rd'], result)\n# Set flags\nset_flag('Z', result == 0)\nset_flag('N', (result & 0x8000) != 0)",
        "encoding": {
          "fields": [
            {"name": "imm", "bits": "15:9", "type": "immediate", "signed": true},
            {"name": "rd", "bits": "8:6", "type": "register"},
            {"name": "func3", "bits": "5:3", "value": "100"},
            {"name": "opcode", "bits": "2:0", "value": "001"}
          ]
        }
      },
      {
        "mnemonic": "ANDI",
        "format": "I-type",
        "description": "AND immediate",
        "syntax": "ANDI rd, imm",
        "semantics": "rd = (rd & sign_extend(imm, 7)) & 0xFFFF",
        "implementation": "# AND immediate implementation\nrd_val = read_register(operands['rd'])\nimm_val = operands['imm']\n# Sign extend 7-bit immediate\nif imm_val & 0x40:\n    imm_val = imm_val | 0xFF80\nresult = (rd_val & (imm_val & 0xFFFF)) & 0xFFFF\nwrite_register(operands['rd'], result)\n# Set flags\nset_flag('Z', result == 0)\nset_flag('N', (result & 0x8000) != 0)",
        "encoding": {
          "fields": [
            {"name": "imm", "bits": "15:9", "type": "immediate", "signed": true},
            {"name": "rd", "bits": "8:6", "type": "register"},
            {"name": "func3", "bits": "5:3", "value": "101"},
            {"name": "opcode", "bits": "2:0", "value": "001"}
          ]
        }
      },
      {
        "mnemonic": "XORI",
        "format": "I-type",
        "description": "XOR immediate",
        "syntax": "XORI rd, imm",
        "semantics": "rd = (rd ^ sign_extend(imm, 7)) & 0xFFFF",
        "implementation": "# XOR immediate implementation\nrd_val = read_register(operands['rd'])\nimm_val = operands['imm']\n# Sign extend 7-bit immediate\nif imm_val & 0x40:\n    imm_val = imm_val | 0xFF80\nresult = (rd_val ^ (imm_val & 0xFFFF)) & 0xFFFF\nwrite_register(operands['rd'], result)\n# Set flags\nset_flag('Z', result == 0)\nset_flag('N', (result & 0x8000) != 0)",
        "encoding": {
          "fields": [
            {"name": "imm", "bits": "15:9", "type": "immediate", "signed": true},
            {"name": "rd", "bits": "8:6", "type": "register"},
            {"name": "func3", "bits": "5:3", "value": "110"},
            {"name": "opcode", "bits": "2:0", "value": "001"}
          ]
        }
      },
      {
        "mnemonic": "LI",
        "format": "I-type",
        "description": "Load immediate",
        "syntax": "LI rd, imm",
        "semantics": "rd = (sign_extend(imm, 7)) & 0xFFFF",
        "implementation": "# Load immediate implementation\nimm_val = operands['imm']\n# Sign extend 7-bit immediate\nif imm_val & 0x40:\n    imm_val = imm_val | 0xFF80\nresult = imm_val & 0xFFFF\nwrite_register(operands['rd'], result)\n# Set flags\nset_flag('Z', result == 0)\nset_flag('N', (result & 0x8000) != 0)",
        "encoding": {
          "fields": [
            {"name": "imm", "bits": "15:9", "type": "immediate", "signed": true},
            {"name": "rd", "bits": "8:6", "type": "register"},
            {"name": "func3", "bits": "5:3", "value": "111"},
            {"name": "opcode", "bits": "2:0", "value": "001"}
          ]
        }
      },
      {
        "mnemonic": "BEQ",
        "format": "B-type",
        "description": "Branch if equal",
        "syntax": "BEQ rs1, rs2, offset",
        "semantics": "if rs1 == rs2: PC = (PC + sign_extend(offset, 4)) & 0xFFFF",
        "implementation": "# Branch if equal implementation\nrs1_val = read_register(operands['rs1'])\nrs2_val = read_register(operands['rs2'])\noffset = operands['imm']\n# Sign extend 4-bit offset\nif offset & 0x8:\n    offset = offset | 0xFFF0\nif rs1_val == rs2_val:\n    context.pc = (context.pc + offset) & 0xFFFF",
        "encoding": {
          "fields": [
            {"name": "imm", "bits": "15:12", "type": "immediate", "signed": true},
            {"name": "rs2", "bits": "11:9", "type": "register"},
            {"name": "rs1", "bits": "8:6", "type": "register"},
            {"name": "func3", "bits": "5:3", "value": "000"},
            {"name": "opcode", "bits": "2:0", "value": "010"}
          ],
          "offset_base": "current"
        }
      },
      {
        "mnemonic": "BNE",
        "format": "B-type",
        "description": "Branch if not equal",
        "syntax": "BNE rs1, rs2, offset",
        "semantics": "if rs1 != rs2: PC = (PC + sign_extend(offset, 4)) & 0xFFFF",
        "implementation": "# Branch if not equal implementation\nrs1_val = read_register(operands['rs1'])\nrs2_val = read_register(operands['rs2'])\noffset = operands['imm']\n# Sign extend 4-bit offset\nif offset & 0x8:\n    offset = offset | 0xFFF0\nif rs1_val != rs2_val:\n    context.pc = (context.pc + offset) & 0xFFFF",
        "encoding": {
          "fields": [
            {"name": "imm", "bits": "15:12", "type": "immediate", "signed": true},
            {"name": "rs2", "bits": "11:9", "type": "register"},
            {"name": "rs1", "bits": "8:6", "type": "register"},
            {"name": "func3", "bits": "5:3", "value": "001"},
            {"name": "opcode", "bits": "2:0", "value": "010"}
          ],
          "offset_base": "current"
        }
      },
      {
        "mnemonic": "BZ",
        "format": "B-type",
        "description": "Branch if zero",
        "syntax": "BZ rs1, offset",
        "semantics": "if rs1 == 0: PC = (PC + sign_extend(offset, 4)) & 0xFFFF",
        "implementation": "# Branch if zero implementation\nrs1_val = read_register(operands['rs1'])\noffset = operands['imm']\n# Sign extend 4-bit offset\nif offset & 0x8:\n    offset = offset | 0xFFF0\nif rs1_val == 0:\n    context.pc = (context.pc + offset) & 0xFFFF",
        "encoding": {
          "fields": [
            {"name": "imm", "bits": "15:12", "type": "immediate", "signed": true},
            {"name": "rs2", "bits": "11:9", "value": "000"},
            {"name": "rs1", "bits": "8:6", "type": "register"},
            {"name": "func3", "bits": "5:3", "value": "010"},
            {"name": "opcode", "bits": "2:0", "value": "010"}
          ],
          "offset_base": "current"
        }
      },
      {
        "mnemonic": "BNZ",
        "format": "B-type",
        "description": "Branch if not zero",
        "syntax": "BNZ rs1, offset",
        "semantics": "if rs1 != 0: PC = (PC + sign_extend(offset, 4)) & 0xFFFF",
        "implementation": "# Branch if not zero implementation\nrs1_val = read_register(operands['rs1'])\noffset = operands['imm']\n# Sign extend 4-bit offset\nif offset & 0x8:\n    offset = offset | 0xFFF0\nif rs1_val != 0:\n    context.pc = (context.pc + offset) & 0xFFFF",
        "encoding": {
          "fields": [
            {"name": "imm", "bits": "15:12", "type": "immediate", "signed": true},
            {"name": "rs2", "bits": "11:9", "value": "000"},
            {"name": "rs1", "bits": "8:6", "type": "register"},
            {"name": "func3", "bits": "5:3", "value": "011"},
            {"name": "opcode", "bits": "2:0", "value": "010"}
          ],
          "offset_base": "current"
        }
      },
      {
        "mnemonic": "BLT",
        "format": "B-type",
        "description": "Branch if less than (signed)",
        "syntax": "BLT rs1, rs2, offset",
        "semantics": "if rs1 < rs2: PC = (PC + sign_extend(offset, 4)) & 0xFFFF",
        "implementation": "# Branch if less than (signed) implementation\nrs1_val = read_register(operands['rs1'])\nrs2_val = read_register(operands['rs2'])\noffset = operands['imm']\n# Sign extend 4-bit offset\nif offset & 0x8:\n    offset = offset | 0xFFF0\n# Sign extend to 32 bits for comparison\nrs1_signed = rs1_val if (rs1_val & 0x8000) == 0 else rs1_val - 0x10000\nrs2_signed = rs2_val if (rs2_val & 0x8000) == 0 else rs2_val - 0x10000\nif rs1_signed < rs2_signed:\n    context.pc = (context.pc + offset) & 0xFFFF",
        "encoding": {
          "fields": [
            {"name": "imm", "bits": "15:12", "type": "immediate", "signed": true},
            {"name": "rs2", "bits": "11:9", "type": "register"},
            {"name": "rs1", "bits": "8:6", "type": "register"},
            {"name": "func3", "bits": "5:3", "value": "100"},
            {"name": "opcode", "bits": "2:0", "value": "010"}
          ],
          "offset_base": "current"
        }
      },
      {
        "mnemonic": "BGE",
        "format": "B-type",
        "description": "Branch if greater or equal (signed)",
        "syntax": "BGE rs1, rs2, offset",
        "semantics": "if rs1 >= rs2: PC = (PC + sign_extend(offset, 4)) & 0xFFFF",
        "implementation": "# Branch if greater or equal (signed) implementation\nrs1_val = read_register(operands['rs1'])\nrs2_val = read_register(operands['rs2'])\noffset = operands['imm']\n# Sign extend 4-bit offset\nif offset & 0x8:\n    offset = offset | 0xFFF0\n# Sign extend to 32 bits for comparison\nrs1_signed = rs1_val if (rs1_val & 0x8000) == 0 else rs1_val - 0x10000\nrs2_signed = rs2_val if (rs2_val & 0x8000) == 0 else rs2_val - 0x10000\nif rs1_signed >= rs2_signed:\n    context.pc = (context.pc + offset) & 0xFFFF",
        "encoding": {
          "fields": [
            {"name": "imm", "bits": "15:12", "type": "immediate", "signed": true},
            {"name": "rs2", "bits": "11:9", "type": "register"},
            {"name": "rs1", "bits": "8:6", "type": "register"},
            {"name": "func3", "bits": "5:3", "value": "101"},
            {"name": "opcode", "bits": "2:0", "value": "010"}
          ],
          "offset_base": "current"
        }
      },
      {
        "mnemonic": "BLTU",
        "format": "B-type",
        "description": "Branch if less than (unsigned)",
        "syntax": "BLTU rs1, rs2, offset",
        "semantics": "if unsigned(rs1) < unsigned(rs2): PC = (PC + sign_extend(offset, 4)) & 0xFFFF",
        "implementation": "# Branch if less than (unsigned) implementation\nrs1_val = read_register(operands['rs1'])\nrs2_val = read_register(operands['rs2'])\noffset = operands['imm']\n# Sign extend 4-bit offset\nif offset & 0x8:\n    offset = offset | 0xFFF0\nif rs1_val < rs2_val:\n    context.pc = (context.pc + offset) & 0xFFFF",
        "encoding": {
          "fields": [
            {"name": "imm", "bits": "15:12", "type": "immediate", "signed": true},
            {"name": "rs2", "bits": "11:9", "type": "register"},
            {"name": "rs1", "bits": "8:6", "type": "register"},
            {"name": "func3", "bits": "5:3", "value": "110"},
            {"name": "opcode", "bits": "2:0", "value": "010"}
          ],
          "offset_base": "current"
        }
      },
      {
        "mnemonic": "BGEU",
        "format": "B-type",
        "description": "Branch if greater or equal (unsigned)",
        "syntax": "BGEU rs1, rs2, offset",
        "semantics": "if (unsigned)rs1 >= rs2: PC = (PC + sign_extend(offset, 4)) & 0xFFFF",
        "implementation": "# Branch if greater or equal (unsigned) implementation\nrs1_val = read_register(operands['rs1'])\nrs2_val = read_register(operands['rs2'])\noffset = operands['imm']\n# Sign extend 4-bit offset\nif offset & 0x8:\n    offset = offset | 0xFFF0\nif rs1_val >= rs2_val:\n    context.pc = (context.pc + offset) & 0xFFFF",
        "encoding": {
          "fields": [
            {"name": "imm", "bits": "15:12", "type": "immediate", "signed": true},
            {"name": "rs2", "bits": "11:9", "type": "register"},
            {"name": "rs1", "bits": "8:6", "type": "register"},
            {"name": "func3", "bits": "5:3", "value": "111"},
            {"name": "opcode", "bits": "2:0", "value": "010"}
          ],
          "offset_base": "current"
        }
      },
      {
        "mnemonic": "SB",
        "format": "S-type",
        "description": "Store byte",
        "syntax": "SB rs2, offset(rs1)",
        "semantics": "memory[rs1 + sign_extend(offset, 4)] = rs2 & 0xFFFF",
        "implementation": "# Store byte implementation\nrs1_val = read_register(operands['rs1'])\nrs2_val = read_register(operands['rs2'])\noffset = operands['imm']\n# Sign extend 4-bit offset\nif offset & 0x8:\n    offset = offset | 0xFFF0\naddr = (rs1_val + offset) & 0xFFFF\n# Store low byte\nif addr < len(memory):\n    memory[addr] = rs2_val & 0xFF",
        "encoding": {
          "fields": [
            {"name": "imm", "bits": "15:12", "type": "immediate", "signed": true},
            {"name": "rs2", "bits": "11:9", "type": "register"},
            {"name": "rs1", "bits": "8:6", "type": "register"},
            {"name": "func3", "bits": "5:3", "value": "000"},
            {"name": "opcode", "bits": "2:0", "value": "011"}
          ]
        }
      },
      {
        "mnemonic": "SW",
        "format": "S-type",
        "description": "Store word",
        "syntax": "SW rs2, offset(rs1)",
        "semantics": "memory[rs1 + sign_extend(offset, 4)] = rs2 & 0xFFFF",
        "implementation": "# Store word implementation\nrs1_val = read_register(operands['rs1'])\nrs2_val = read_register(operands['rs2'])\noffset = operands['imm']\n# Sign extend 4-bit offset\nif offset & 0x8:\n    offset = offset | 0xFFF0\naddr = (rs1_val + offset) & 0xFFFF\n# Store 16-bit word (little endian)\nif addr + 1 < len(memory):\n    memory[addr] = rs2_val & 0xFF\n    memory[addr + 1] = (rs2_val >> 8) & 0xFF",
        "encoding": {
          "fields": [
            {"name": "imm", "bits": "15:12", "type": "immediate", "signed": true},
            {"name": "rs2", "bits": "11:9", "type": "register"},
            {"name": "rs1", "bits": "8:6", "type": "register"},
            {"name": "func3", "bits": "5:3", "value": "001"},
            {"name": "opcode", "bits": "2:0", "value": "011"}
          ]
        }
      },
      {
        "mnemonic": "LB",
        "format": "L-type",
        "description": "Load byte",
        "syntax": "LB rd, offset(rs2)",
        "semantics": "rd = sign_extend(memory[rs2 + sign_extend(offset, 4)] & 0x7F, 4) & 0xFFFF",
        "implementation": "# Load byte implementation\nrs2_val = read_register(operands['rs2'])\noffset = operands['imm']\n# Sign extend 4-bit offset\nif offset & 0x8:\n    offset = offset | 0xFFF0\naddr = (rs2_val + offset) & 0xFFFF\n# Load byte and sign extend\nif addr < len(memory):\n    byte_val = memory[addr]\n    # Sign extend 8-bit to 16-bit\n    if byte_val & 0x80:\n        result = byte_val | 0xFF00\n    else:\n        result = byte_val\n    write_register(operands['rd'], result)",
        "encoding": {
          "fields": [
            {"name": "imm", "bits": "15:12", "type": "immediate", "signed": true},
            {"name": "rs2", "bits": "11:9", "type": "register"},
            {"name": "rd", "bits": "8:6", "type": "register"},
            {"name": "func3", "bits": "5:3", "value": "000"},
            {"name": "opcode", "bits": "2:0", "value": "100"}
          ]
        }
      },
      {
        "mnemonic": "LW",
        "format": "L-type",
        "description": "Load word",
        "syntax": "LW rd, offset(rs2)",
        "semantics": "rd = memory[rs2 + sign_extend(offset, 4)] & 0xFFFF",
        "implementation": "# Load word implementation\nrs2_val = read_register(operands['rs2'])\noffset = operands['imm']\n# Sign extend 4-bit offset\nif offset & 0x8:\n    offset = offset | 0xFFF0\naddr = (rs2_val + offset) & 0xFFFF\n# Load 16-bit word (little endian)\nif addr + 1 < len(memory):\n    result = memory[addr] | (memory[addr + 1] << 8)\n    write_register(operands['rd'], result)",
        "encoding": {
          "fields": [
            {"name": "imm", "bits": "15:12", "type": "immediate", "signed": true},
            {"name": "rs2", "bits": "11:9", "type": "register"},
            {"name": "rd", "bits": "8:6", "type": "register"},
            {"name": "func3", "bits": "5:3", "value": "001"},
            {"name": "opcode", "bits": "2:0", "value": "100"}
          ]
        }
      },
      {
        "mnemonic": "LBU",
        "format": "L-type",
        "description": "Load byte unsigned",
        "syntax": "LBU rd, offset(rs2)",
        "semantics": "rd = memory[rs2 + sign_extend(offset, 4)] & 0xFFFF",
        "implementation": "# Load byte unsigned implementation\nrs2_val = read_register(operands['rs2'])\noffset = operands['imm']\n# Sign extend 4-bit offset\nif offset & 0x8:\n    offset = offset | 0xFFF0\naddr = (rs2_val + offset) & 0xFFFF\n# Load byte and zero extend\nif addr < len(memory):\n    result = memory[addr] & 0xFF\n    write_register(operands['rd'], result)",
        "encoding": {
          "fields": [
            {"name": "imm", "bits": "15:12", "type": "immediate", "signed": true},
            {"name": "rs2", "bits": "11:9", "type": "register"},
            {"name": "rd", "bits": "8:6", "type": "register"},
            {"name": "func3", "bits": "5:3", "value": "100"},
            {"name": "opcode", "bits": "2:0", "value": "100"}
          ]
        }
      },
      {
        "mnemonic": "J",
        "format": "J-type",
        "description": "Jump",
        "syntax": "J offset",
        "semantics": "PC = (PC + sign_extend(offset, 6)) & 0xFFFF",
        "implementation": "# Jump implementation\nimm1 = operands['imm']\nimm2 = operands['imm2']\n# Combine 6-bit and 3-bit immediates\noffset = (imm1 << 3) | imm2\n# Sign extend 9-bit offset\nif offset & 0x100:\n    offset = offset | 0xFE00\ncontext.pc = (context.pc + offset) & 0xFFFF",
        "encoding": {
          "fields": [
            {"name": "link", "bits": "15:15", "value": "0"},
            {"name": "imm", "bits": "14:9", "type": "immediate", "signed": true},
            {"name": "rd", "bits": "8:6", "value": "000"},
            {"name": "imm2", "bits": "5:3", "type": "immediate", "signed": true},
            {"name": "opcode", "bits": "2:0", "value": "101"}
          ]
        }
      },
      {
        "mnemonic": "JAL",
        "format": "J-type",
        "description": "Jump and link",
        "syntax": "JAL rd, offset",
        "semantics": "rd = PC + 2; PC = (PC + sign_extend(offset, 6)) & 0xFFFF",
        "implementation": "# Jump and link implementation\nimm1 = operands['imm']\nimm2 = operands['imm2']\n# Combine 6-bit and 3-bit immediates\noffset = (imm1 << 3) | imm2\n# Sign extend 9-bit offset\nif offset & 0x100:\n    offset = offset | 0xFE00\n# Save return address\nreturn_addr = context.pc + 2\nwrite_register(operands['rd'], return_addr)\n# Jump\ncontext.pc = (context.pc + offset) & 0xFFFF",
        "encoding": {
          "fields": [
            {"name": "link", "bits": "15:15", "value": "1"},
            {"name": "imm", "bits": "14:9", "type": "immediate", "signed": true},
            {"name": "rd", "bits": "8:6", "type": "register"},
            {"name": "imm2", "bits": "5:3", "type": "immediate", "signed": true},
            {"name": "opcode", "bits": "2:0", "value": "101"}
          ]
        }
      },
      {
        "mnemonic": "LUI",
        "format": "U-type",
        "description": "Load upper immediate",
        "syntax": "LUI rd, imm",
        "semantics": "rd = (sign_extend(imm, 6) << 7) & 0xFFFF",
        "implementation": "# Load upper immediate implementation\nimm1 = operands['imm']\nimm2 = operands['imm2']\n# Combine 6-bit and 3-bit immediates\nimm = (imm1 << 3) | imm2\n# Shift left by 7 bits\nresult = (imm << 7) & 0xFFFF\nwrite_register(operands['rd'], result)",
        "encoding": {
          "fields": [
            {"name": "flag", "bits": "15:15", "value": "0"},
            {"name": "imm", "bits": "14:9", "type": "immediate", "signed": false},
            {"name": "rd", "bits": "8:6", "type": "register"},
            {"name": "imm2", "bits": "5:3", "type": "immediate", "signed": false},
            {"name": "opcode", "bits": "2:0", "value": "110"}
          ]
        }
      },
      {
        "mnemonic": "AUIPC",
        "format": "U-type",
        "description": "Add upper immediate to PC",
        "syntax": "AUIPC rd, imm",
        "semantics": "rd = (PC + (sign_extend(imm, 6) << 7)) & 0xFFFF",
        "implementation": "# Add upper immediate to PC implementation\nimm1 = operands['imm']\nimm2 = operands['imm2']\n# Combine 6-bit and 3-bit immediates\nimm = (imm1 << 3) | imm2\n# Shift left by 7 bits and add to PC\nresult = (context.pc + (imm << 7)) & 0xFFFF\nwrite_register(operands['rd'], result)",
        "encoding": {
          "fields": [
            {"name": "flag", "bits": "15:15", "value": "1"},
            {"name": "imm", "bits": "14:9", "type": "immediate", "signed": false},
            {"name": "rd", "bits": "8:6", "type": "register"},
            {"name": "imm2", "bits": "5:3", "type": "immediate", "signed": false},
            {"name": "opcode", "bits": "2:0", "value": "110"}
          ]
        }
      },
      {
        "mnemonic": "ECALL",
        "format": "SYS-type",
        "description": "Environment call",
        "syntax": "ECALL svc",
        "semantics": "Trap to service number",
        "implementation": "# Environment call implementation\nsvc = operands['svc']\n# Handle system call based on service number\n# This is a placeholder - actual implementation would depend on system services\n# For now, just store the service number in a special register or flag\nset_flag('SVC', svc)\n# Could also trigger an interrupt or system call handler here",
        "encoding": {
          "fields": [
            {"name": "svc", "bits": "15:6", "type": "immediate", "signed": false},
            {"name": "unused", "bits": "5:3", "value": "000"},
            {"name": "opcode", "bits": "2:0", "value": "111"}
          ]
                }
      }
    ],
    "directives": [
    {
      "name": ".org",
      "description": "Set origin address",
      "action": "set_origin",
      "implementation": "# Set origin directive implementation\nif args:\n    addr = int(args[0], 0)  # Parse as hex/decimal\n    context.current_address = addr\n    assembler.context.current_address = addr\n    assembler.symbol_table.set_current_address(addr)",
      "argument_types": ["number"],
      "syntax": ".org address",
      "examples": [".org 0x1000", ".org 4096"]
    },
    {
      "name": ".word",
      "description": "Define word data",
      "action": "define_word",
      "implementation": "# Define word directive implementation\nresult = bytearray()\nfor arg in args:\n    value = int(arg, 0)  # Parse as hex/decimal\n    # Little endian 16-bit word\n    result.extend([value & 0xFF, (value >> 8) & 0xFF])\n    context.current_address += 2\nassembler.context.current_address = context.current_address\nassembler.symbol_table.set_current_address(context.current_address)",
      "argument_types": ["number"],
      "syntax": ".word value1, value2, ...",
      "examples": [".word 0x1234", ".word 42, 0xABCD"]
    },
    {
      "name": ".byte",
      "description": "Define byte data",
      "action": "define_byte",
      "implementation": "# Define byte directive implementation\nresult = bytearray()\nfor arg in args:\n    value = int(arg, 0)  # Parse as hex/decimal\n    result.append(value & 0xFF)\n    context.current_address += 1\nassembler.context.current_address = context.current_address\nassembler.symbol_table.set_current_address(context.current_address)",
      "argument_types": ["number"],
      "syntax": ".byte value1, value2, ...",
      "examples": [".byte 0x12", ".byte 65, 66, 67", ".byte 'A'"]
    },
    {
      "name": ".ascii",
      "description": "Define ASCII string",
      "action": "define_ascii",
      "implementation": "# Define ASCII string directive implementation\nif args:\n    string = args[0].strip('\"\\'')\n    result = bytearray(string.encode('ascii'))\n    context.current_address += len(result)\n    assembler.context.current_address = context.current_address\n    assembler.symbol_table.set_current_address(context.current_address)",
      "argument_types": ["string"],
      "syntax": ".ascii \"string\"",
      "examples": [".ascii \"Hello, World!\"", ".ascii \"Hello\""]
    },
    {
      "name": ".align",
      "description": "Align to boundary",
      "action": "align",
      "implementation": "# Align directive implementation\nif args:\n    alignment = int(args[0])\n    padding = (alignment - (context.current_address % alignment)) % alignment\n    if padding > 0:\n        result = bytearray([0] * padding)\n        context.current_address += padding\n        assembler.context.current_address = context.current_address\n        assembler.symbol_table.set_current_address(context.current_address)",
      "argument_types": ["number"],
      "syntax": ".align boundary",
      "examples": [".align 4", ".align 16", ".align 2"]
    },
    {
      "name": ".text",
      "description": "Code section (default)",
      "action": "set_section",
      "implementation": "# Text section directive implementation\ncontext.current_section = 'text'\nassembler.context.current_section = 'text'\n# Set default code start address if not already set\nif context.current_address == 0:\n    context.current_address = 32\n    assembler.context.current_address = 32",
      "argument_types": [],
      "syntax": ".text",
      "examples": [".text"]
    },
    {
      "name": ".data",
      "description": "Data section",
      "action": "set_section",
      "implementation": "# Data section directive implementation\ncontext.current_section = 'data'\nassembler.context.current_section = 'data'\n# Set default data start address if not already set\nif context.current_address < 0x1000:\n    context.current_address = 0x1000\n    assembler.context.current_address = 0x1000",
      "argument_types": [],
      "syntax": ".data",
      "examples": [".data"]
    },
    {
      "name": ".bss",
      "description": "Uninitialized data section",
      "action": "set_section",
      "implementation": "# BSS section directive implementation\ncontext.current_section = 'bss'\nassembler.context.current_section = 'bss'\n# Set default BSS start address if not already set\nif context.current_address < 0x2000:\n    context.current_address = 0x2000\n    assembler.context.current_address = 0x2000",
      "argument_types": [],
      "syntax": ".bss",
      "examples": [".bss"]
    },
    {
      "name": ".string",
      "description": "Null-terminated string",
      "action": "define_string",
      "implementation": "# Define string directive implementation\nif args:\n    string = args[0].strip('\"\\'')\n    # Process escape sequences\n    string = string.replace('\\\\n', '\\n').replace('\\\\t', '\\t').replace('\\\\r', '\\r')\n    result = bytearray(string.encode('ascii'))\n    result.append(0)  # Add null terminator\n    context.current_address += len(result)\n    assembler.context.current_address = context.current_address\n    assembler.symbol_table.set_current_address(context.current_address)",
      "argument_types": ["string"],
      "syntax": ".string \"string\"",
      "examples": [".string \"Hello\\n\"", ".string \"World\""]
    },
    {
      "name": ".space",
      "description": "Reserve bytes (zero-filled)",
      "action": "reserve_space",
      "implementation": "# Reserve space directive implementation\nif args:\n    size = int(args[0], 0)\n    result = bytearray([0] * size)\n    context.current_address += size\n    assembler.context.current_address = context.current_address\n    assembler.symbol_table.set_current_address(context.current_address)",
      "argument_types": ["number"],
      "syntax": ".space size",
      "examples": [".space 10", ".space 0x100"]
    },
    {
      "name": ".fill",
      "description": "Fill items with value",
      "action": "fill_data",
      "implementation": "# Fill directive implementation\nif len(args) >= 3:\n    count = int(args[0], 0)\n    size = int(args[1], 0)\n    value = int(args[2], 0)\n    result = bytearray()\n    for i in range(count):\n        if size == 1:\n            result.append(value & 0xFF)\n        elif size == 2:\n            result.extend([value & 0xFF, (value >> 8) & 0xFF])\n    context.current_address += len(result)\n    assembler.context.current_address = context.current_address\n    assembler.symbol_table.set_current_address(context.current_address)",
      "argument_types": ["number", "number", "number"],
      "syntax": ".fill count, size, value",
      "examples": [".fill 5, 2, 0xFFFF", ".fill 10, 1, 0x42"]
    },
    {
      "name": ".equ",
      "description": "Define constant",
      "action": "define_constant",
      "implementation": "# Define constant directive implementation\nif len(args) >= 2:\n    symbol = args[0]\n    value = int(args[1], 0)\n    assembler.symbol_table.define_symbol(symbol, value)\n    context.constants[symbol] = value",
      "argument_types": ["symbol", "number"],
      "syntax": ".equ symbol, value",
      "examples": [".equ STACK_SIZE, 0x400", ".equ MAX_COUNT, 100"]
    },
    {
      "name": ".set",
      "description": "Define constant (same as .equ)",
      "action": "define_constant",
      "implementation": "# Define constant directive implementation (same as .equ)\nif len(args) >= 2:\n    symbol = args[0]\n    value = int(args[1], 0)\n    assembler.symbol_table.define_symbol(symbol, value)\n    context.constants[symbol] = value",
      "argument_types": ["symbol", "number"],
      "syntax": ".set symbol, value",
      "examples": [".set MAX_COUNT, 100", ".set BUFFER_SIZE, 256"]
    },
    {
      "name": ".global",
      "description": "Export symbol",
      "action": "export_symbol",
      "implementation": "# Export symbol directive implementation\nif args:\n    symbol = args[0]\n    assembler.symbol_table.mark_global(symbol)\n    context.global_symbols.add(symbol)",
      "argument_types": ["symbol"],
      "syntax": ".global symbol",
      "examples": [".global main", ".global _start"]
    },
    {
      "name": ".extern",
      "description": "Import external symbol",
      "action": "import_symbol",
      "implementation": "# Import external symbol directive implementation\nif args:\n    symbol = args[0]\n    assembler.symbol_table.mark_external(symbol)\n    context.external_symbols.add(symbol)",
      "argument_types": ["symbol"],
      "syntax": ".extern symbol",
      "examples": [".extern external_func", ".extern printf"]
    },
    {
      "name": ".ifdef",
      "description": "Conditional assembly if defined",
      "action": "conditional_ifdef",
      "implementation": "# Conditional ifdef directive implementation\nif args:\n    symbol = args[0]\n    condition = symbol in context.constants or symbol in assembler.symbol_table.symbols\n    context.conditional_stack.append(('ifdef', condition))\n    context.skip_assembly = not condition",
      "argument_types": ["symbol"],
      "syntax": ".ifdef symbol",
      "examples": [".ifdef DEBUG", ".ifdef RELEASE"]
    },
    {
      "name": ".ifndef",
      "description": "Conditional assembly if not defined",
      "action": "conditional_ifndef",
      "implementation": "# Conditional ifndef directive implementation\nif args:\n    symbol = args[0]\n    condition = symbol not in context.constants and symbol not in assembler.symbol_table.symbols\n    context.conditional_stack.append(('ifndef', condition))\n    context.skip_assembly = not condition",
      "argument_types": ["symbol"],
      "syntax": ".ifndef symbol",
      "examples": [".ifndef RELEASE", ".ifndef DEBUG"]
    },
    {
      "name": ".if",
      "description": "Conditional assembly if expression true",
      "action": "conditional_if",
      "implementation": "# Conditional if directive implementation\nif args:\n    expression = ' '.join(args)\n    # Simple expression evaluation (would need full parser in real implementation)\n    try:\n        condition = eval(expression, {}, context.constants)\n        context.conditional_stack.append(('if', bool(condition)))\n        context.skip_assembly = not bool(condition)\n    except:\n        context.conditional_stack.append(('if', False))\n        context.skip_assembly = True",
      "argument_types": ["expression"],
      "syntax": ".if expression",
      "examples": [".if STACK_SIZE > 0x200", ".if DEBUG == 1"]
    },
    {
      "name": ".else",
      "description": "Conditional assembly else clause",
      "action": "conditional_else",
      "implementation": "# Conditional else directive implementation\nif context.conditional_stack:\n    cond_type, prev_condition = context.conditional_stack[-1]\n    context.conditional_stack[-1] = (cond_type, not prev_condition)\n    context.skip_assembly = not context.conditional_stack[-1][1]",
      "argument_types": [],
      "syntax": ".else",
      "examples": [".else"]
    },
    {
      "name": ".endif",
      "description": "End conditional assembly block",
      "action": "conditional_endif",
      "implementation": "# Conditional endif directive implementation\nif context.conditional_stack:\n    context.conditional_stack.pop()\n    # Restore previous conditional state\n    context.skip_assembly = any(not cond for _, cond in context.conditional_stack)",
      "argument_types": [],
      "syntax": ".endif",
      "examples": [".endif"]
    },
    {
      "name": ".include",
      "description": "Include another file",
      "action": "include_file",
      "implementation": "# Include file directive implementation\nif args:\n    filename = args[0].strip('\"\\'')\n    try:\n        with open(filename, 'r') as f:\n            included_content = f.read()\n        # Process included file content\n        assembler.process_source(included_content, filename)\n    except FileNotFoundError:\n        raise AssemblerError(f'Include file not found: {filename}')",
      "argument_types": ["string"],
      "syntax": ".include \"filename\"",
      "examples": [".include \"constants.asm\"", ".include \"macros.inc\""]
    },
    {
      "name": ".incbin",
      "description": "Include binary file",
      "action": "include_binary",
      "implementation": "# Include binary file directive implementation\nif args:\n    filename = args[0].strip('\"\\'')\n    try:\n        with open(filename, 'rb') as f:\n            binary_data = f.read()\n        result = bytearray(binary_data)\n        context.current_address += len(result)\n        assembler.context.current_address = context.current_address\n        assembler.symbol_table.set_current_address(context.current_address)\n    except FileNotFoundError:\n        raise AssemblerError(f'Binary file not found: {filename}')",
      "argument_types": ["string"],
      "syntax": ".incbin \"filename\"",
      "examples": [".incbin \"data.bin\"", ".incbin \"image.raw\""]
    }
  ],
    "pseudo_instructions": [
      {
        "mnemonic": "NOP",
        "description": "No operation",
        "syntax": "NOP",
        "expansion": "ADD x0, x0"
      },
      {
        "mnemonic": "CLR",
        "description": "Clear register",
        "syntax": "CLR rd",
        "expansion": "XOR rd, rd"
      },
      {
        "mnemonic": "INC",
        "description": "Increment register",
        "syntax": "INC rd",
        "expansion": "ADDI rd, 1"
      },
      {
        "mnemonic": "DEC",
        "description": "Decrement register",
        "syntax": "DEC rd",
        "expansion": "ADDI rd, -1"
      },
      {
        "mnemonic": "NOT",
        "description": "Bitwise NOT",
        "syntax": "NOT rd",
        "expansion": "XORI rd, -1"
      },
      {
        "mnemonic": "NEG",
        "description": "Negate register",
        "syntax": "NEG rd",
        "expansion": "XORI rd, -1; ADDI rd, 1"
      },
      {
        "mnemonic": "CALL",
        "description": "Call function",
        "syntax": "CALL label",
        "expansion": "JAL x1, label"
      },
      {
        "mnemonic": "RET",
        "description": "Return from function",
        "syntax": "RET",
        "expansion": "JR x1"
      },
      {
        "mnemonic": "JMP",
        "description": "Unconditional jump",
        "syntax": "JMP label",
        "expansion": "J label"
      },
      {
        "mnemonic": "LI16",
        "description": "Load 16-bit immediate",
        "syntax": "LI16 rd, imm",
        "expansion": "LUI rd, imm[15:9]; ORI rd, imm[8:0]"
      },
      {
        "mnemonic": "LA",
        "description": "Load address",
        "syntax": "LA rd, label",
        "expansion": "AUIPC rd, label[15:9]; ADDI rd, label[8:0]"
      },
      {
        "mnemonic": "PUSH",
        "description": "Push register to stack",
        "syntax": "PUSH rd",
        "expansion": "ADDI x2, -2; SW rd, 0(x2)"
      },
      {
        "mnemonic": "POP",
        "description": "Pop from stack to register",
        "syntax": "POP rd",
        "expansion": "LW rd, 0(x2); ADDI x2, 2"
      }
    ],
    "assembly_syntax": {
      "comment_chars": ["#", ";"],
      "label_suffix": ":",
      "register_prefix": "",
      "immediate_prefix": "",
      "string_delimiters": ["\"", "'"],
      "case_sensitive": false,
      "instruction_separator": "\n"
    },
    "constants": {
      "RESET_VECTOR": 0,
      "INT_VECTORS": 0,
      "CODE_START": 32,
      "MMIO_BASE": 61440,
      "MMIO_SIZE": 4096,
      "STACK_TOP": 61438,
      "MEM_SIZE": 65536
    },
    "ecall_services": {
      "0x001": {
        "name": "read_string",
        "description": "Read string into buffer at a0, up to a1 bytes. Output: a0=string length",
        "parameters": {
          "a0": "Address of the string buffer (input/output)",
          "a1": "Maximum length of string to read (input)"
        },
        "return": "a0: String length read"
      },
      "0x002": {
        "name": "read_integer",
        "description": "Read an integer from input. Output: a0=the read integer",
        "parameters": {},
        "return": "a0: The read integer"
      },
      "0x003": {
        "name": "print_string",
        "description": "Print string starting at address in a0 register",
        "parameters": {
          "a0": "Address of null-terminated string"
        },
        "return": "None"
      },
      "0x004": {
        "name": "play_tone",
        "description": "Play tone with frequency and duration",
        "parameters": {
          "a0": "Frequency (Hz)",
          "a1": "Duration (ms)"
        },
        "return": "None"
      },
      "0x005": {
        "name": "set_audio_volume",
        "description": "Set audio volume (0-255)",
        "parameters": {
          "a0": "Volume (0-255)"
        },
        "return": "None"
      },
      "0x006": {
        "name": "stop_audio_playback",
        "description": "Stop audio playback",
        "parameters": {},
        "return": "None"
      },
      "0x007": {
        "name": "read_keyboard",
        "description": "Read the keyboard: a0=key code, a1=1 if key pressed, 0 if not",
        "parameters": {},
        "return": "a0: Key code, a1: 1 if key pressed, 0 if not"
      },
      "0x008": {
        "name": "registers_dump",
        "description": "Prints the values of all registers",
        "parameters": {},
        "return": "None"
      },
      "0x009": {
        "name": "memory_dump",
        "description": "Prints the content of memory from address in a0 for number of bytes in a1",
        "parameters": {
          "a0": "Start address",
          "a1": "Number of bytes"
        },
        "return": "None"
      },
      "0x00A": {
        "name": "exit",
        "description": "Exit program with code in a0 register",
        "parameters": {
          "a0": "Exit code"
        },
        "return": "None"
      }
    }
  } 